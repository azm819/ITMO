/*
Полный ориентированный взвешенный граф задан матрицей смежности. Постройте матрицу кратчайших путей между его вершинами. 
Гарантируется, что в графе нет циклов отрицательного веса.

Входные данные
В первой строке вводится единственное число N (1 ≤ N ≤ 100) — количество вершин графа. 
В следующих N строках по N чисел задается матрица смежности графа (j-ое число в i-ой строке — вес ребра из вершины i в вершину j). 
Все числа по модулю не превышают 100. На главной диагонали матрицы — всегда нули.

Выходные данные
Выведите N строк по N чисел — матрицу расстояний между парами вершин, где j-ое число в i-ой строке равно весу кратчайшего пути из вершины i в j.
*/

#include <fstream>
#include <vector>
#include <cmath>
#include <iostream>
using namespace std;
vector <vector <int>> graph;
const int INF = 1010;
int main(){
    int n;
    cin >> n;
    graph.resize(n);
    for(int i = 0; i < n; ++i){
        graph[i].resize(n);
        for(int j = 0; j < n; j++){
            cin >> graph[i][j];
        }
        graph[i][i] = INF;
    }
    for(int i = 0; i < n; ++i){
        for(int u = 0; u < n; u++){
            for(int v = 0; v < n; v++){
                graph[u][v] = min(graph[u][v], graph[u][i] + graph[i][v]);
            }
        }
    }
    for(int i = 0; i < n; i++){
        for(int j = 0; j < n; j++){
            cout << ((i == j) ? 0 : graph[i][j]);
            cout << " ";
        }
        cout << endl;
    }
    return 0;
}